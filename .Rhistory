#number of answers should sampled from each selected question
answerSamplingStep <- 2;
#How many of the top ranking should be considered to predict bugs
rankingTop <- 2;
#start with one answer
questionID_f <- data.frame(unique(answerPopulation_df$Question.ID));
colnames(questionID_f)<- c("Question.ID");
#Sample with replacement fits the assumptions of infinite population, unknown distribution,
#and equal probability of any programmer to provide an answer
sampled_dataf<-sampleWithReplacement(questionList=questionID_f,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
for(i in 1:10){
#### compute precision recall accuracy sensitivity
answersByQuestions_df <- runFromSample(sampled_dataf);
#Select only the question with ranking position equal of higher than rankingTop (see setup above)
predictedBugs <- answersByQuestions_df[answersByQuestions_df$rankingVote<=rankingTop,];
statistics_f<- computeStatistics(predictedBugs,actualBugs); #change name of computeOutcomes to computeStat
statistics_f$answers <- dim(sampled_dataf)[1];
accumStatistics <- rbind(accumStatistics,statistics_f);
#compute utility
utility_table<-difficulty_utility(df=sampled_dataf);
#select top questions from each JavaMethod
topQuestions <- selectTopQuestionsByJavaMethod(utility_table,
sampled_dataf,
questionsToSelect)
#sample more answers from these questions
sampledAnswers_topQuestions<-sampleWithReplacement(questionList=topQuestions,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
##Append the sampled answers to the exisintg answers of the top questions
sampled_dataf <- rbind(sampled_dataf,sampledAnswers_topQuestions);
}
plotOutcomes(utilityType="difficulty",U=questionsToSelect,A=answerSamplingStep,R=rankingTop);
#Compute different utility values for questions
library(dplyr);
confidence_utility<-function(df){
subset_df<-subset(df,select=c(Answer.confidence))
#mark all rows that match the selection
conf.1<- rowSums(subset_df=="1");
subset_df["conf.1"] <- conf.1;
conf.2<- rowSums(subset_df=="2");
subset_df["conf.2"] <- conf.2;
conf.3<- rowSums(subset_df=="3");
subset_df["conf.3"] <- conf.3;
conf.4<- rowSums(subset_df=="4");
subset_df["conf.4"] <- conf.4;
conf.5<- rowSums(subset_df=="5");
subset_df["conf.5"] <- conf.5;
subset_df["QuestionID"] <- df$Question.ID;
subset_df <-subset(subset_df,select= c(QuestionID,conf.1,conf.2,conf.3,conf.4,conf.5));
question_by <- group_by(subset_df,QuestionID);
summaryTable<- summarize(question_by,
Total_1 = sum(conf.1),Total_2 = sum(conf.2),
Total_3 = sum(conf.3),Total_4=sum(conf.4),
Total_5 = sum(conf.5));
colnames(summaryTable)<-c("Question.ID","conf.1","conf.2","conf.3","conf.4","conf.5");
summaryTable["utility"]<-summaryTable$conf.1+2*summaryTable$conf.2+0*summaryTable$conf.3+
4*summaryTable$conf.4+5*summaryTable$conf.5;
return(summaryTable);
}
difficulty_utility<-function(df){
subset_df<-subset(df,select=c(Answer.difficulty))
#mark all rows that match the selection
diff.1<- rowSums(subset_df=="1");
subset_df["conf.1"] <- conf.1;
diff.2<- rowSums(subset_df=="2");
subset_df["conf.2"] <- conf.2;
diff.3<- rowSums(subset_df=="3");
subset_df["conf.3"] <- conf.3;
diff.4<- rowSums(subset_df=="4");
subset_df["conf.4"] <- conf.4;
diff.5<- rowSums(subset_df=="5");
subset_df["conf.5"] <- conf.5;
subset_df["QuestionID"] <- df$Question.ID;
subset_df <-subset(subset_df,select= c(QuestionID,diff.1,diff.2,diff.3,diff.4,diff.5));
question_by <- group_by(subset_df,QuestionID);
summaryTable<- summarize(question_by,
Total_1 = sum(diff.1),Total_2 = sum(diff.2),
Total_3 = sum(diff.3),Total_4=sum(diff.4),
Total_5 = sum(diff.5));
colnames(summaryTable)<-c("Question.ID","diff.1","diff.2","diff.3","diff.4","diff.5");
summaryTable["utility"]<-summaryTable$diff.1+2*summaryTable$diff.2+3*summaryTable$diff.3+
4*summaryTable$diff.4+5*summaryTable$diff.5;
return(summaryTable);
}
# Import data
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_VotingAggregation//loadAllAnswers.R");
answerPopulation_df <- loadAnswers("answerList_data.csv");
#Initialize variables
accumStatistics<- list(precision=0, recall=0, sensitivity=0, accuracy=0, answers=0);
actualBugs <- c(1,4,10,14,20,23,30,32,55,56,57,58,59,72,73,77,84,92,95,97,102,104,115,119,123);
topQuestions <-list();
#number of high utility question values that should be sampled
#This is same as ranking, it can be that more than one question has the same utility
questionsToSelect <- 3;
#number of answers should sampled from each selected question
answerSamplingStep <- 2;
#How many of the top ranking should be considered to predict bugs
rankingTop <- 2;
#start with one answer
questionID_f <- data.frame(unique(answerPopulation_df$Question.ID));
colnames(questionID_f)<- c("Question.ID");
#Sample with replacement fits the assumptions of infinite population, unknown distribution,
#and equal probability of any programmer to provide an answer
sampled_dataf<-sampleWithReplacement(questionList=questionID_f,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
for(i in 1:10){
#### compute precision recall accuracy sensitivity
answersByQuestions_df <- runFromSample(sampled_dataf);
#Select only the question with ranking position equal of higher than rankingTop (see setup above)
predictedBugs <- answersByQuestions_df[answersByQuestions_df$rankingVote<=rankingTop,];
statistics_f<- computeStatistics(predictedBugs,actualBugs); #change name of computeOutcomes to computeStat
statistics_f$answers <- dim(sampled_dataf)[1];
accumStatistics <- rbind(accumStatistics,statistics_f);
#compute utility
utility_table<-difficulty_utility(df=sampled_dataf);
#select top questions from each JavaMethod
topQuestions <- selectTopQuestionsByJavaMethod(utility_table,
sampled_dataf,
questionsToSelect)
#sample more answers from these questions
sampledAnswers_topQuestions<-sampleWithReplacement(questionList=topQuestions,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
##Append the sampled answers to the exisintg answers of the top questions
sampled_dataf <- rbind(sampled_dataf,sampledAnswers_topQuestions);
}
plotOutcomes(utilityType="difficulty",U=questionsToSelect,A=answerSamplingStep,R=rankingTop);
library(ggplot2)
#Run a Monte Carlo simulation that selects questions based on utility function
#Two nested simulations: sample answers to compute utility and sample answers to compute precision/recall
######################################################################################################
# Initialize methods
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_QuestionUtility//computeConfusionMatrix.R");
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_QuestionUtility//utilityFunctions.R");
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_QuestionUtility//samplingFunctions.R");
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_VotingAggregation//aggregateVotes.R");
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_VotingAggregation//aggregateAnswerOptionsPerQuestion.R");
# Import data
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_VotingAggregation//loadAllAnswers.R");
answerPopulation_df <- loadAnswers("answerList_data.csv");
#Initialize variables
accumStatistics<- list(precision=0, recall=0, sensitivity=0, accuracy=0, answers=0);
actualBugs <- c(1,4,10,14,20,23,30,32,55,56,57,58,59,72,73,77,84,92,95,97,102,104,115,119,123);
topQuestions <-list();
#number of high utility question values that should be sampled
#This is same as ranking, it can be that more than one question has the same utility
questionsToSelect <- 3;
#number of answers should sampled from each selected question
answerSamplingStep <- 2;
#How many of the top ranking should be considered to predict bugs
rankingTop <- 2;
#start with one answer
questionID_f <- data.frame(unique(answerPopulation_df$Question.ID));
colnames(questionID_f)<- c("Question.ID");
#Sample with replacement fits the assumptions of infinite population, unknown distribution,
#and equal probability of any programmer to provide an answer
sampled_dataf<-sampleWithReplacement(questionList=questionID_f,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
for(i in 1:10){
#### compute precision recall accuracy sensitivity
answersByQuestions_df <- runFromSample(sampled_dataf);
#Select only the question with ranking position equal of higher than rankingTop (see setup above)
predictedBugs <- answersByQuestions_df[answersByQuestions_df$rankingVote<=rankingTop,];
statistics_f<- computeStatistics(predictedBugs,actualBugs); #change name of computeOutcomes to computeStat
statistics_f$answers <- dim(sampled_dataf)[1];
accumStatistics <- rbind(accumStatistics,statistics_f);
#compute utility
utility_table<-difficulty_utility(df=sampled_dataf);
#select top questions from each JavaMethod
topQuestions <- selectTopQuestionsByJavaMethod(utility_table,
sampled_dataf,
questionsToSelect)
#sample more answers from these questions
sampledAnswers_topQuestions<-sampleWithReplacement(questionList=topQuestions,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
##Append the sampled answers to the exisintg answers of the top questions
sampled_dataf <- rbind(sampled_dataf,sampledAnswers_topQuestions);
}
plotOutcomes(utilityType="difficulty",U=questionsToSelect,A=answerSamplingStep,R=rankingTop);
#Compute different utility values for questions
library(dplyr);
confidence_utility<-function(df){
subset_df<-subset(df,select=c(Answer.confidence))
#mark all rows that match the selection
conf.1<- rowSums(subset_df=="1");
subset_df["conf.1"] <- conf.1;
conf.2<- rowSums(subset_df=="2");
subset_df["conf.2"] <- conf.2;
conf.3<- rowSums(subset_df=="3");
subset_df["conf.3"] <- conf.3;
conf.4<- rowSums(subset_df=="4");
subset_df["conf.4"] <- conf.4;
conf.5<- rowSums(subset_df=="5");
subset_df["conf.5"] <- conf.5;
subset_df["QuestionID"] <- df$Question.ID;
subset_df <-subset(subset_df,select= c(QuestionID,conf.1,conf.2,conf.3,conf.4,conf.5));
question_by <- group_by(subset_df,QuestionID);
summaryTable<- summarize(question_by,
Total_1 = sum(conf.1),Total_2 = sum(conf.2),
Total_3 = sum(conf.3),Total_4=sum(conf.4),
Total_5 = sum(conf.5));
colnames(summaryTable)<-c("Question.ID","conf.1","conf.2","conf.3","conf.4","conf.5");
summaryTable["utility"]<-summaryTable$conf.1+2*summaryTable$conf.2+0*summaryTable$conf.3+
4*summaryTable$conf.4+5*summaryTable$conf.5;
return(summaryTable);
}
difficulty_utility<-function(df){
subset_df<-subset(df,select=c(Answer.difficulty))
#mark all rows that match the selection
diff.1<- rowSums(subset_df=="1");
subset_df["diff.1"] <- diff.1;
diff.2<- rowSums(subset_df=="2");
subset_df["diff.2"] <- diff.2;
diff.3<- rowSums(subset_df=="3");
subset_df["diff.3"] <- diff.3;
diff.4<- rowSums(subset_df=="4");
subset_df["diff.4"] <- diff.4;
diff.5<- rowSums(subset_df=="5");
subset_df["diff.5"] <- diff.5;
subset_df["QuestionID"] <- df$Question.ID;
subset_df <-subset(subset_df,select= c(QuestionID,diff.1,diff.2,diff.3,diff.4,diff.5));
question_by <- group_by(subset_df,QuestionID);
summaryTable<- summarize(question_by,
Total_1 = sum(diff.1),Total_2 = sum(diff.2),
Total_3 = sum(diff.3),Total_4=sum(diff.4),
Total_5 = sum(diff.5));
colnames(summaryTable)<-c("Question.ID","diff.1","diff.2","diff.3","diff.4","diff.5");
summaryTable["utility"]<-summaryTable$diff.5+2*summaryTable$diff.4+0*summaryTable$diff.3+
4*summaryTable$diff.2+5*summaryTable$diff.1;
return(summaryTable);
}
library(ggplot2)
#Run a Monte Carlo simulation that selects questions based on utility function
#Two nested simulations: sample answers to compute utility and sample answers to compute precision/recall
######################################################################################################
# Initialize methods
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_QuestionUtility//computeConfusionMatrix.R");
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_QuestionUtility//utilityFunctions.R");
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_QuestionUtility//samplingFunctions.R");
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_VotingAggregation//aggregateVotes.R");
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_VotingAggregation//aggregateAnswerOptionsPerQuestion.R");
# Import data
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_VotingAggregation//loadAllAnswers.R");
answerPopulation_df <- loadAnswers("answerList_data.csv");
#Initialize variables
accumStatistics<- list(precision=0, recall=0, sensitivity=0, accuracy=0, answers=0);
actualBugs <- c(1,4,10,14,20,23,30,32,55,56,57,58,59,72,73,77,84,92,95,97,102,104,115,119,123);
topQuestions <-list();
#number of high utility question values that should be sampled
#This is same as ranking, it can be that more than one question has the same utility
questionsToSelect <- 3;
#number of answers should sampled from each selected question
answerSamplingStep <- 2;
#How many of the top ranking should be considered to predict bugs
rankingTop <- 2;
#start with one answer
questionID_f <- data.frame(unique(answerPopulation_df$Question.ID));
colnames(questionID_f)<- c("Question.ID");
#Sample with replacement fits the assumptions of infinite population, unknown distribution,
#and equal probability of any programmer to provide an answer
sampled_dataf<-sampleWithReplacement(questionList=questionID_f,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
for(i in 1:10){
#### compute precision recall accuracy sensitivity
answersByQuestions_df <- runFromSample(sampled_dataf);
#Select only the question with ranking position equal of higher than rankingTop (see setup above)
predictedBugs <- answersByQuestions_df[answersByQuestions_df$rankingVote<=rankingTop,];
statistics_f<- computeStatistics(predictedBugs,actualBugs); #change name of computeOutcomes to computeStat
statistics_f$answers <- dim(sampled_dataf)[1];
accumStatistics <- rbind(accumStatistics,statistics_f);
#compute utility
utility_table<-difficulty_utility(df=sampled_dataf);
#select top questions from each JavaMethod
topQuestions <- selectTopQuestionsByJavaMethod(utility_table,
sampled_dataf,
questionsToSelect)
#sample more answers from these questions
sampledAnswers_topQuestions<-sampleWithReplacement(questionList=topQuestions,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
##Append the sampled answers to the exisintg answers of the top questions
sampled_dataf <- rbind(sampled_dataf,sampledAnswers_topQuestions);
}
plotOutcomes(utilityType="difficulty",U=questionsToSelect,A=answerSamplingStep,R=rankingTop);
#Compute different utility values for questions
library(dplyr);
confidence_utility<-function(df){
subset_df<-subset(df,select=c(Answer.confidence))
#mark all rows that match the selection
conf.1<- rowSums(subset_df=="1");
subset_df["conf.1"] <- conf.1;
conf.2<- rowSums(subset_df=="2");
subset_df["conf.2"] <- conf.2;
conf.3<- rowSums(subset_df=="3");
subset_df["conf.3"] <- conf.3;
conf.4<- rowSums(subset_df=="4");
subset_df["conf.4"] <- conf.4;
conf.5<- rowSums(subset_df=="5");
subset_df["conf.5"] <- conf.5;
subset_df["QuestionID"] <- df$Question.ID;
subset_df <-subset(subset_df,select= c(QuestionID,conf.1,conf.2,conf.3,conf.4,conf.5));
question_by <- group_by(subset_df,QuestionID);
summaryTable<- summarize(question_by,
Total_1 = sum(conf.1),Total_2 = sum(conf.2),
Total_3 = sum(conf.3),Total_4=sum(conf.4),
Total_5 = sum(conf.5));
colnames(summaryTable)<-c("Question.ID","conf.1","conf.2","conf.3","conf.4","conf.5");
summaryTable["utility"]<-summaryTable$conf.1+2*summaryTable$conf.2+0*summaryTable$conf.3+
4*summaryTable$conf.4+5*summaryTable$conf.5;
return(summaryTable);
}
difficulty_utility<-function(df){
subset_df<-subset(df,select=c(Answer.difficulty))
#mark all rows that match the selection
diff.1<- rowSums(subset_df=="1");
subset_df["diff.1"] <- diff.1;
diff.2<- rowSums(subset_df=="2");
subset_df["diff.2"] <- diff.2;
diff.3<- rowSums(subset_df=="3");
subset_df["diff.3"] <- diff.3;
diff.4<- rowSums(subset_df=="4");
subset_df["diff.4"] <- diff.4;
diff.5<- rowSums(subset_df=="5");
subset_df["diff.5"] <- diff.5;
subset_df["QuestionID"] <- df$Question.ID;
subset_df <-subset(subset_df,select= c(QuestionID,diff.1,diff.2,diff.3,diff.4,diff.5));
question_by <- group_by(subset_df,QuestionID);
summaryTable<- summarize(question_by,
Total_1 = sum(diff.1),Total_2 = sum(diff.2),
Total_3 = sum(diff.3),Total_4=sum(diff.4),
Total_5 = sum(diff.5));
colnames(summaryTable)<-c("Question.ID","diff.1","diff.2","diff.3","diff.4","diff.5");
summaryTable["utility"]<-(-2)*summaryTable$diff.5+(-1)*summaryTable$diff.4+0*summaryTable$diff.3+
4*summaryTable$diff.2+5*summaryTable$diff.1;
return(summaryTable);
}
answerPopulation_df <- loadAnswers("answerList_data.csv");
#Initialize variables
accumStatistics<- list(precision=0, recall=0, sensitivity=0, accuracy=0, answers=0);
actualBugs <- c(1,4,10,14,20,23,30,32,55,56,57,58,59,72,73,77,84,92,95,97,102,104,115,119,123);
topQuestions <-list();
#number of high utility question values that should be sampled
#This is same as ranking, it can be that more than one question has the same utility
questionsToSelect <- 3;
#number of answers should sampled from each selected question
answerSamplingStep <- 2;
#How many of the top ranking should be considered to predict bugs
rankingTop <- 2;
#start with one answer
questionID_f <- data.frame(unique(answerPopulation_df$Question.ID));
colnames(questionID_f)<- c("Question.ID");
#Sample with replacement fits the assumptions of infinite population, unknown distribution,
#and equal probability of any programmer to provide an answer
sampled_dataf<-sampleWithReplacement(questionList=questionID_f,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
for(i in 1:10){
#### compute precision recall accuracy sensitivity
answersByQuestions_df <- runFromSample(sampled_dataf);
#Select only the question with ranking position equal of higher than rankingTop (see setup above)
predictedBugs <- answersByQuestions_df[answersByQuestions_df$rankingVote<=rankingTop,];
statistics_f<- computeStatistics(predictedBugs,actualBugs); #change name of computeOutcomes to computeStat
statistics_f$answers <- dim(sampled_dataf)[1];
accumStatistics <- rbind(accumStatistics,statistics_f);
#compute utility
utility_table<-difficulty_utility(df=sampled_dataf);
#select top questions from each JavaMethod
topQuestions <- selectTopQuestionsByJavaMethod(utility_table,
sampled_dataf,
questionsToSelect)
#sample more answers from these questions
sampledAnswers_topQuestions<-sampleWithReplacement(questionList=topQuestions,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
##Append the sampled answers to the exisintg answers of the top questions
sampled_dataf <- rbind(sampled_dataf,sampledAnswers_topQuestions);
}
plotOutcomes(utilityType="difficulty",U=questionsToSelect,A=answerSamplingStep,R=rankingTop);
answerPopulation_df <- loadAnswers("answerList_data.csv");
#Initialize variables
accumStatistics<- list(precision=0, recall=0, sensitivity=0, accuracy=0, answers=0);
actualBugs <- c(1,4,10,14,20,23,30,32,55,56,57,58,59,72,73,77,84,92,95,97,102,104,115,119,123);
topQuestions <-list();
#number of high utility question values that should be sampled
#This is same as ranking, it can be that more than one question has the same utility
questionsToSelect <- 3;
#number of answers should sampled from each selected question
answerSamplingStep <- 2;
#How many of the top ranking should be considered to predict bugs
rankingTop <- 2;
#start with one answer
questionID_f <- data.frame(unique(answerPopulation_df$Question.ID));
colnames(questionID_f)<- c("Question.ID");
#Sample with replacement fits the assumptions of infinite population, unknown distribution,
#and equal probability of any programmer to provide an answer
sampled_dataf<-sampleWithReplacement(questionList=questionID_f,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
for(i in 1:10){
#### compute precision recall accuracy sensitivity
answersByQuestions_df <- runFromSample(sampled_dataf);
#Select only the question with ranking position equal of higher than rankingTop (see setup above)
predictedBugs <- answersByQuestions_df[answersByQuestions_df$rankingVote<=rankingTop,];
statistics_f<- computeStatistics(predictedBugs,actualBugs); #change name of computeOutcomes to computeStat
statistics_f$answers <- dim(sampled_dataf)[1];
accumStatistics <- rbind(accumStatistics,statistics_f);
#compute utility
utility_table<-difficulty_utility(df=sampled_dataf);
#select top questions from each JavaMethod
topQuestions <- selectTopQuestionsByJavaMethod(utility_table,
sampled_dataf,
questionsToSelect)
#sample more answers from these questions
sampledAnswers_topQuestions<-sampleWithReplacement(questionList=topQuestions,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
##Append the sampled answers to the exisintg answers of the top questions
sampled_dataf <- rbind(sampled_dataf,sampledAnswers_topQuestions);
}
plotOutcomes(utilityType="difficulty",U=questionsToSelect,A=answerSamplingStep,R=rankingTop);
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_VotingAggregation//loadAllAnswers.R");
answerPopulation_df <- loadAnswers("answerList_data.csv");
#Initialize variables
accumStatistics<- list(precision=0, recall=0, sensitivity=0, accuracy=0, answers=0);
actualBugs <- c(1,4,10,14,20,23,30,32,55,56,57,58,59,72,73,77,84,92,95,97,102,104,115,119,123);
topQuestions <-list();
#number of high utility question values that should be sampled
#This is same as ranking, it can be that more than one question has the same utility
questionsToSelect <- 3;
#number of answers should sampled from each selected question
answerSamplingStep <- 3;
#How many of the top ranking should be considered to predict bugs
rankingTop <- 2;
#start with one answer
questionID_f <- data.frame(unique(answerPopulation_df$Question.ID));
colnames(questionID_f)<- c("Question.ID");
#Sample with replacement fits the assumptions of infinite population, unknown distribution,
#and equal probability of any programmer to provide an answer
sampled_dataf<-sampleWithReplacement(questionList=questionID_f,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
for(i in 1:10){
#### compute precision recall accuracy sensitivity
answersByQuestions_df <- runFromSample(sampled_dataf);
#Select only the question with ranking position equal of higher than rankingTop (see setup above)
predictedBugs <- answersByQuestions_df[answersByQuestions_df$rankingVote<=rankingTop,];
statistics_f<- computeStatistics(predictedBugs,actualBugs); #change name of computeOutcomes to computeStat
statistics_f$answers <- dim(sampled_dataf)[1];
accumStatistics <- rbind(accumStatistics,statistics_f);
#compute utility
utility_table<-difficulty_utility(df=sampled_dataf);
#select top questions from each JavaMethod
topQuestions <- selectTopQuestionsByJavaMethod(utility_table,
sampled_dataf,
questionsToSelect)
#sample more answers from these questions
sampledAnswers_topQuestions<-sampleWithReplacement(questionList=topQuestions,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
##Append the sampled answers to the exisintg answers of the top questions
sampled_dataf <- rbind(sampled_dataf,sampledAnswers_topQuestions);
}
plotOutcomes(utilityType="difficulty",U=questionsToSelect,A=answerSamplingStep,R=rankingTop);
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_VotingAggregation//loadAllAnswers.R");
answerPopulation_df <- loadAnswers("answerList_data.csv");
#Initialize variables
accumStatistics<- list(precision=0, recall=0, sensitivity=0, accuracy=0, answers=0);
actualBugs <- c(1,4,10,14,20,23,30,32,55,56,57,58,59,72,73,77,84,92,95,97,102,104,115,119,123);
topQuestions <-list();
#number of high utility question values that should be sampled
#This is same as ranking, it can be that more than one question has the same utility
questionsToSelect <- 3;
#number of answers should sampled from each selected question
answerSamplingStep <- 1;
#How many of the top ranking should be considered to predict bugs
rankingTop <- 2;
#start with one answer
questionID_f <- data.frame(unique(answerPopulation_df$Question.ID));
colnames(questionID_f)<- c("Question.ID");
#Sample with replacement fits the assumptions of infinite population, unknown distribution,
#and equal probability of any programmer to provide an answer
sampled_dataf<-sampleWithReplacement(questionList=questionID_f,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
for(i in 1:10){
#### compute precision recall accuracy sensitivity
answersByQuestions_df <- runFromSample(sampled_dataf);
#Select only the question with ranking position equal of higher than rankingTop (see setup above)
predictedBugs <- answersByQuestions_df[answersByQuestions_df$rankingVote<=rankingTop,];
statistics_f<- computeStatistics(predictedBugs,actualBugs); #change name of computeOutcomes to computeStat
statistics_f$answers <- dim(sampled_dataf)[1];
accumStatistics <- rbind(accumStatistics,statistics_f);
#compute utility
utility_table<-difficulty_utility(df=sampled_dataf);
#select top questions from each JavaMethod
topQuestions <- selectTopQuestionsByJavaMethod(utility_table,
sampled_dataf,
questionsToSelect)
#sample more answers from these questions
sampledAnswers_topQuestions<-sampleWithReplacement(questionList=topQuestions,
population = answerPopulation_df,
sampleSize = answerSamplingStep);
##Append the sampled answers to the exisintg answers of the top questions
sampled_dataf <- rbind(sampled_dataf,sampledAnswers_topQuestions);
}
plotOutcomes(utilityType="difficulty",U=questionsToSelect,A=answerSamplingStep,R=rankingTop);
